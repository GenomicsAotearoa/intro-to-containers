{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Reproducible computational environments using containers","text":"<p>This lesson provides an introduction to using the Apptainer container platform. Apptainer is particularly suited to running containers on infrastructure where users don\u2019t have administrative privileges, for example shared infrastructure such as High Performance Computing (HPC) clusters.</p> <p>This lesson will introduce Apptainer from scratch showing you how to run a simple container and building up to creating your own containers and running parallel scientific workloads on HPC infrastructure.</p> <p>Schedule</p> <ol> <li>Getting Started with Containers <ul> <li>What is a container and why might I want to use it?</li> </ul> </li> <li>The Container Cache Why does Apptainer use a local cache?<ul> <li>Where does Apptainer store images?</li> <li>How do I configure my cache ?</li> </ul> </li> <li>Using containers to run commands <ul> <li>How do I use container software on the cluster?</li> <li>How do I run different commands within a container?</li> <li>How do I access an interactive shell within a container?</li> </ul> </li> <li> <p>Files in containers </p> <ul> <li>How do I make data available in a container?</li> <li>What data is made available by default in a container?</li> </ul> </li> <li> <p>Creating Container Images </p> <ul> <li>How can I make my own Apptainer container images?</li> <li>How do I document the \u2018recipe\u2019 for a Apptainer container image</li> </ul> </li> <li>Building Container Images <ul> <li>How do I create my own Apptainer images?</li> </ul> </li> </ol>"},{"location":"1.getting-started-with-containers/","title":"1. Getting Started with Containers","text":"<p>Overview</p> <p>Questions - What is a container and why might I want to use it?</p> <p>Objectives Understand what a container is and when you might want to use it.</p> <p>The episodes in this lesson will introduce you to the Apptainer container platform and demonstrate how to set up and use Apptainer.</p>"},{"location":"1.getting-started-with-containers/#what-are-containers","title":"What are Containers","text":"<p>A container is an entity providing an isolated software environment (or filesystem) for an application and its dependencies.</p> <p>If you have already used a Virtual Machine, or VM, you\u2019re actually already familiar with some of the concepts of a container.</p> <p></p> <p>The key difference here is that VMs virtualise hardware while containers virtualise operating systems. There are other differences (and benefits), in particular containers are:</p> <ul> <li>lighter weight to run (less CPU and memory usage, faster start-up times)</li> <li>smaller in size (thus easier to transfer and share)</li> <li>modular (possible to combine multiple containers that work together)</li> </ul> <p>Since containers do not virtualise the hardware, containers must be built using the same architecture as the machine they are going to be deployed on. Containers built for one architecture cannot run on the other.</p>"},{"location":"1.getting-started-with-containers/#containers-and-your-workflow","title":"Containers and your workflow","text":"<p>There are a number of reasons for using containers in your daily work:</p> <ul> <li>Data reproducibility/provenance</li> <li>Cross-system portability</li> <li>Simplified collaboration</li> <li>Simplified software dependencies and management</li> <li>Consistent testing environment</li> </ul>"},{"location":"1.getting-started-with-containers/#terminology","title":"Terminology","text":"<p>We\u2019ll start with a brief note on the terminology used in this section of the course. We refer to both images and containers. What is the distinction between these two terms?</p> <p>Images are bundles of files including an operating system, software and potentially data and other application-related files. They may sometimes be referred to as a disk image or container image and they may be stored in different ways, perhaps as a single file, or as a group of files. Either way, we refer to this file, or collection of files, as an image.</p> <p>A container is a virtual environment that is based on an image. That is, the files, applications, tools, etc that are available within a running container are determined by the image that the container is started from. It may be possible to start multiple container instances from an image. You could, perhaps, consider an image to be a form of template from whi***ch running container instances can be started.</p> <p>A registry is a server application where images are stored and can be accessed by users. It can be public (e.g. Docker Hub) or private.</p> <p>To build an image we need a recipe. A recipe file is called a Definition File, or def file, in the Apptainer jargon and a Dockerfile in the Docker world.</p>"},{"location":"1.getting-started-with-containers/#container-engines","title":"Container engines","text":"<p>A number of tools are available to create, deploy and run containerised applications. Some of these will be covered throughout this tutorial:</p> <p>Commonly used engines</p> <p>Docker</p> <p></p> <p>The first engine to gain popularity, still widely used in the IT industry. Not very suitable for HPC as it requires root privileges to run.</p> <p>See the documentation for more information.</p> <p>Singularity</p> <p></p> <p>A simple, powerful root-less container engine for the HPC world. Originally developed at the Lawrence Berkeley National Laboratory.</p> <p>Apptainer</p> <p> A simple, powerful root-less container engine for the HPC world. Originally developed at the Lawrence Berkeley National Laboratory.</p> <p></p> <p>That concludes this container overview. The next episode looks in more detail at setting up your environment for running containers on the NeSI cluster.</p> <p>Key points</p> <ul> <li>Containers enable you to package up an application and its dependencies.</li> <li>By using containers, you can better enforce reproducibility, portability and share-ability of your computational workflows.</li> <li>Apptainer (and Singularity) are container platforms and are often used in cluster/HPC/research environments.</li> <li>Apptainer has a different security model to other container platforms, one of the key reasons that it is well suited to HPC and cluster environments.</li> <li>Apptainer has its own container image format based off the original Singularity Image Format (SIF).</li> <li>The apptainer command can be used to pull images from Docker Hub or other locations such as a website and run a container from an image file.</li> </ul>"},{"location":"2.container-cache/","title":"2. The Container Cache","text":"<p>Overview</p> <p>Questions</p> <ul> <li>Why does Apptainer use a local cache?</li> <li>Where does Apptainer store images?</li> <li>How do I configure my cache to work on NeSI?</li> </ul> <p>Objectives </p> <ul> <li>Learn about Apptainer\u2019s image cache.</li> <li>Learn howto setup your cache on Mahuika</li> </ul> <p>Verify the installation and check the version</p> <pre><code>$ apptainer --version\n</code></pre> <pre><code>apptainer version 1.3.0\n</code></pre>"},{"location":"2.container-cache/#using-the-image-cache-and-temporary-directories","title":"Using the image cache and temporary directories","text":"<p>Pull an ubuntu Linux image from DockerHub</p> <p>code</p> <pre><code>$ apptainer pull docker://ubuntu \n</code></pre> <pre><code>INFO:    Converting OCI blobs to SIF format\nINFO:    Starting build...\nGetting image source signatures\nCopying blob 3c645031de29 done   | \nCopying config 7af9ba4f0a done   | \nWriting manifest to image destination\n2024/04/25 12:26:02  info unpack layer: sha256:3c645031de2917ade93ec54b118d5d3e45de72ef580b8f419a8cdc41e01d042c\nINFO:    Creating SIF file...\n</code></pre> <p>So what we did here was to use the <code>docker://</code> URL to tell apptainer to go to DockerHub and pull the Ubuntu Docker image. Apptainer pulls the image and converts it into the image file format used by Apptainer and Singularity: <code>.sif</code>. The image file is save in our current directory as <code>ubuntu_latest.sif</code> and a cached copy is in the <code>$HOME/.apptainer/cache</code></p> <p>Apptainer doesn\u2019t have a local image repository in the same way as Docker, however, it does cache downloaded image files. Apptainer also uses a temporary directory for building images.</p> <p>If you delete the .sif image that you have pulled from a remote image repository such as DockerHub, and then pull it again, provided the image is unchanged from the version you previously pulled, you will be given a copy of the image file from your local cache rather than the image being downloaded again from the remote source. This removes unnecessary network transfers and is particularly useful for large images which may take some time to transfer over the network. To demonstrate this, remove the ubuntu_latest.sif file stored in your directory and then issue the pull command again:</p> <p>code</p> <pre><code>$ rm ubuntu_latest.sif\n$ apptainer pull docker://ubuntu\n</code></pre>"},{"location":"2.container-cache/#cleaning-the-apptainer-image-cache","title":"Cleaning the Apptainer image cache","text":"<p>We can remove images from the cache using the <code>apptainer cache clean</code> command. Running the command without any options will display a warning and ask you to confirm that you want to remove everything from your cache. This is very useful if you are running low on space or do not want to keep old images on disk.</p> <p>You can also remove specific images or all images of a particular type. Look at the output of <code>apptainer cache clean --help</code> for more information.</p> <p>Apptainer Cache and Temporary files  : How to change the default path</p> <p>By default, Apptainer uses <code>$HOME/.apptainer</code> as the location for cache and temporary files. </p> <p>You can change the location of the cache by setting environment variables to the cache and temporary directory locations you want to use. Those environment variables are: <code>APPTAINER_CACHEDIR</code> &amp; <code>APPTAINER_TMPDIR</code></p> <p>Key points</p> <ul> <li> <p>Apptainer caches downloaded images so that an unchanged image isn\u2019t downloaded again when it is requested using the <code>apptainer pull</code> command.</p> </li> <li> <p>You can free up space in the cache by removing all locally cached images or by specifying individual images to remove.</p> </li> </ul>"},{"location":"3.using-containers-to-run-commands/","title":"3. Using containers to run commands","text":"<p>Overview</p> <p>Questions</p> <ul> <li>How do I use container software on the cluster?</li> <li>How do I run different commands within a container?</li> <li>How do I access an interactive shell within a container?</li> </ul> <p>Objectives</p> <ul> <li>Learn how to run different commands when starting a container.</li> <li>Learn how to open an interactive shell within a container environment.</li> </ul>"},{"location":"3.using-containers-to-run-commands/#pulling-a-new-image-and-running-a-container","title":"Pulling a new image and running a container","text":"<p>Lets continue by pulling a new image from another public image repository and start to work with the container.</p> <p>code</p> <pre><code>$ apptainer pull docker://ghcr.io/apptainer/lolcow\n</code></pre> <pre><code>INFO:    Converting OCI blobs to SIF format\nINFO:    Starting build...\nGetting image source signatures\nCopying blob 5ca731fc36c2 done\nCopying blob 16ec32c2132b done\nCopying config fd0daa4d89 done\nWriting manifest to image destination\nStoring signatures\n2023/02/09 12:20:21  info unpack layer: sha256:16ec32c2132b43494832a05f2b02f7a822479f8250c173d0ab27b3de78b2f058\n2023/02/09 12:20:24  info unpack layer: sha256:5ca731fc36c28789c5ddc3216563e8bfca2ab3ea10347e07554ebba1c953242e\nINFO:    Creating SIF file...\n</code></pre> <p>We pulled a Docker image from a Docker image repo using the<code>apptainer pull</code> command and directed it to store the image file using the default name <code>lolcow_latest.sif</code> in the current directory. If you run the <code>ls</code> command, you should see that the <code>lolcow_latest.sif</code> file is now present in the current directory. This is our image and we can now run a container based on this image:</p> <p>\"code</p> <pre><code>$ apptainer run lolcow_latest.sif \n</code></pre> <pre><code> _______________________________\n&lt; Thu Apr 25 13:05:47 NZST 2024 &gt;\n -------------------------------\n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n</code></pre> <ul> <li>Most images are also directly executable </li> </ul> <pre><code>$ ./lolcow_latest.sif\n</code></pre> <p>How did the container determine what to do when we ran it?! What did running the container actually do to result in the displayed output?</p> <p>When you run a container from a sif image without using any additional command line arguments, the container runs the default run script that is embedded within the image. This is a shell script that can be used to run commands, tools or applications stored within the image on container startup. We can inspect the image\u2019s run script using the <code>apptainer inspect</code> command:</p> <p>code</p> <pre><code>$ apptainer inspect -r lolcow_latest.sif | head\n</code></pre> <pre><code>#!/bin/sh\nOCI_ENTRYPOINT='\"/bin/sh\" \"-c\" \"date | cowsay | lolcat\"'\nOCI_CMD=''\n\n# When SINGULARITY_NO_EVAL set, use OCI compatible behavior that does\n# not evaluate resolved CMD / ENTRYPOINT / ARGS through the shell, and\n# does not modify expected quoting behavior of args.\nif [ -n \"$SINGULARITY_NO_EVAL\" ]; then\n    # ENTRYPOINT only - run entrypoint plus args\n    if [ -z \"$OCI_CMD\" ] &amp;&amp; [ -n \"$OCI_ENTRYPOINT\" ]; then\n</code></pre> <p>This shows us the first 10 lines of the script within the lolcow_latest.sif image configured to run by default when we use the <code>apptainer run</code> command.</p>"},{"location":"3.using-containers-to-run-commands/#running-specific-commands-within-a-container","title":"Running specific commands within a container","text":"<p>We saw earlier that we can use the <code>apptainer inspect</code> command to see the run script that a container is configured to run by default. What if we want to run a different command within a container?</p> <p>If we know the path of an executable that we want to run within a container, we can use the <code>apptainer exec</code> command. For example, using the <code>lolcow_latest.sif</code> container that we\u2019ve already pulled from  DockerHub, we can run the following within the test directory where the <code>lolcow_latest.sif</code> file is located:</p> <p>code</p> <pre><code>$ apptainer exec lolcow_latest.sif echo Hello World!\n</code></pre> <pre><code>Hello World!\n</code></pre> <p>Here we see that a container has been started from the <code>lolcow_latest.sif</code> image and the <code>echo</code> command has been run within the container, passing the input <code>Hello World!</code>. The command has echoed the provided input to the console and the container has terminated.</p> <p>Note that the use of <code>apptainer exec</code> has overriden any run script set within the image metadata and the command that we specified as an argument to <code>apptainer exec</code> has been run instead.</p> <p>Running a different command within the \u201clolcow\u201d container</p> <p>Can you run a command to \"print date and time\"  on the container image <code>lolcow_latest.sif</code></p> Answer <pre><code>$ apptainer exec lolcow_latest.sif date\n</code></pre>"},{"location":"3.using-containers-to-run-commands/#the-difference-between-apptainer-run-and-apptainer-exec","title":"The difference between <code>apptainer run</code> and <code>apptainer exec</code>","text":"<p>Above we used the apptainer <code>exec</code> command. In earlier examples we used <code>apptainer run</code>. To clarify, the difference between these two commands is:</p> <ul> <li> <p><code>apptainer run</code>: This will run the default command set for containers based on the specfied image. This default command is set within the image metadata when the image is built (we\u2019ll see more about this in later episodes). You do not specify a command to run when using <code>apptainer run</code>, you simply specify the image file name. As we saw earlier, you can use the <code>apptainer inspect</code> command to see what command is run by default when starting a new container based on an image.</p> </li> <li> <p><code>apptainer exec</code>: This will start a container based on the specified image and run the command provided on the command line following <code>apptainer exec &lt;image file name&gt;</code>. This will override any default command specified within the image metadata that would otherwise be run if you used <code>apptainer run</code>.</p> </li> </ul>"},{"location":"3.using-containers-to-run-commands/#opening-an-interactive-shell-within-a-container","title":"Opening an interactive shell within a container","text":"<p>If you want to open an interactive shell within a container, Singularity provides the apptainer shell command. Again, using the lolcow_latest.sif image, and within our test directory, we can run a shell within a container from the hello-world image:</p> <p>code</p> <p><pre><code>$ apptainer shell lolcow_latest.sif\n</code></pre> <pre><code>Apptainer&gt; whoami\n</code></pre> <pre><code>Apptainer&gt; pwd\n</code></pre></p> <ul> <li>As shown above, we have opened a shell in a new container started from the <code>lolcow_latest.sif</code> image. Note that the shell prompt has changed to show we are now within the container.</li> </ul> <p>Use the <code>exit</code> command to exit from the container shell.</p> <p>Key Points</p> <ul> <li> <p>The apptainer exec is an alternative to apptainer run that allows you to start a container running a specific command.</p> </li> <li> <p>The apptainer shell command can be used to start a container and run an interactive shell within it.</p> </li> </ul>"},{"location":"4.files-in-containers/","title":"4. Files in containers","text":"<p>Overview</p> <p>Questions</p> <ul> <li>How do I make data available in a container?</li> <li>What data is made available by default in a container?</li> </ul> <p>Objectives</p> <ul> <li>Understand that some data from the host system is usually made available by default within a container</li> <li>Learn more about how handles users and binds directories from the host filesystem.</li> </ul> <p>The way in which user accounts and access permissions are handled in Apptainer containers is very different from that in Docker (where you effectively always have superuser/root access). When running a Apptainer container, you only have the same permissions to access files as the user you are running as on the host system.</p> <p>In this episode we\u2019ll look at working with files in the context of Apptainer containers and how this links with Apptainer\u2019s approach to users and permissions within containers.</p> <p>Users within a Apptainer container The first thing to note is that when you ran whoami within the container shell you started at the end of the previous episode, you should have seen the username that you were signed in as on the host system when you ran the container.</p> <p>For example, if my username were <code>training1</code>, I\u2019d expect to see the following:</p> <p><pre><code>$ apptainer shell lolcow_latest.sif\nApptainer&gt; whoami\ntraining1\n</code></pre> But hang on! I downloaded a version of the <code>lolcow_latest.sif</code> image from a public container repo. I haven\u2019t customised it in any way. How is it configured with my own user details?!</p> <p>If you have any familiarity with Linux system administration, you may be aware that in Linux, users and their Unix groups are configured in the <code>/etc/passwd</code> and <code>/etc/group</code> files respectively. In order for the shell within the container to know of my user, the relevant user information needs to be available within these files within the container.</p> <p>Assuming this feature is enabled within the installation of Apptainer on your system, when the container is started, Apptainer appends the relevant user and group lines from the host system to the <code>/etc/passwd</code> and <code>/etc/group</code> files within the container [1].</p> <p>This means that the host system can effectively ensure that you cannot access/modify/delete any data you should not be able to on the host system and you cannot run anything that you would not have permission to run on the host system since you are restricted to the same user permissions within the container as you are on the host system.</p>"},{"location":"4.files-in-containers/#files-and-directories-within-a-apptainer-container","title":"Files and directories within a Apptainer container","text":"<p>Apptainer also binds some directories from the host system where you are running the <code>apptainer</code> command into the container that you\u2019re starting. Note that this bind process is not copying files into the running container, it is making an existing directory on the host system visible and accessible within the container environment. If you write files to this directory within the running container, when the container shuts down, those changes will persist in the relevant location on the host system.</p> <p>There is a default configuration of which files and directories are bound into the container but ultimate control of how things are set up on the system where you are running Apptainer is determined by the system administrator. As a result, this section provides an overview but you may find that things are a little different on the system that you\u2019re running on.</p> <p>One directory that is likely to be accessible within a container that you start is your home directory. You may also find that the directory from which you issued the apptainer command (the current working directory) is also mapped.</p> <p>The mapping of file content and directories from a host system into a Apptainer container is illustrated in the example below showing a subset of the directories on the host Linux system and in a Apptainer container:</p>"},{"location":"5.creating-container-images/","title":"5. Creating Container images","text":"<p>Overview</p> <p>Questions</p> <ul> <li>How can I make my own Apptainer container images?</li> <li>How do I document the \u2018recipe\u2019 for a Apptainer container image</li> </ul> <p>Objectives</p> <ul> <li>Explain the purpose of a Apptainer Definition File and show some simple examples</li> <li>Understand the different Singularity container file formats.</li> <li>Understand how to build and share your own Apptainer containers.</li> <li>Compare the steps of creating a container image interactively versus a Definition file.</li> </ul> <p>There are lots of reasons why you might want to create your own Apptainer container image.</p> <ul> <li>You can\u2019t find an existing container image with all the tools you need.</li> <li>You want to have a container image to \u201carchive\u201d all the specific software versions you ran for a project.</li> <li>You want to share your workflow with someone else.</li> </ul>"},{"location":"5.creating-container-images/#sandbox-installation","title":"Sandbox installation","text":"<p>The most intuitive way to build a container is to do so interactively, this allows you to install packages, configure applications and test commands, then when finished export as an image.</p> <p>This is possible using the <code>--sandbox flag</code>, for example</p> <p><pre><code>$ sudo apptainer build --sandbox ubuntu docker://ubuntu\n</code></pre> This creates an image called <code>ubuntu</code> bootstrapped from <code>docker://ubuntu</code> You can then run</p> <p><pre><code>$ sudo apptainer shell --writable ubuntu\n</code></pre> To start setting up your workflow.</p> <p>However, there are two big problems with this approach, firstly building a sandbox image requires you to have root access on your machine and therefore unavailable to many people, secondly it doesn\u2019t provide the best support for our ultimate goal of reproducibility.</p> <p>This is because, even though you can share the image, the steps taken to create it are unclear. <code>-sandbox</code> should only be used for initial prototyping of your image, the rest of the time you should use a definition file.</p>"},{"location":"5.creating-container-images/#creating-a-apptainer-definition-file","title":"Creating a Apptainer Definition File","text":"<p>The Apptainer Definition File is a text file that contains a series of statements that are used to create a container image. In line with the configuration as code approach mentioned above, the definition file can be stored in your code repository alongside your application code and used to create a reproducible image. This means that for a given commit in your repository, the version of the definition file present at that commit can be used to reproduce a container with a known state. It was pointed out earlier in the course, when covering Docker, that this property also applies for Dockerfiles.</p> <p>Now lets start writing a very simple definition file, make a new file called<code>my_container.def</code>. (Either with your command line text editor of choice, or with the Jupyter text editor).</p> <p>The first two lines we are going to add define where to bootstrap our image from, we cannot just put some application binaries into a blank image, we need the standard system libraries and potentially a wide range of other libraries and tools.</p> <p>The most straightforward way to achieve this is to start from an existing base image containing an operating system. In this case, we\u2019re going to start from a minimal Ubuntu 20.04 Linux Docker image. Note that we\u2019re using a Docker image as the basis for creating a Apptainer image.</p> <p>c</p> <pre><code>Bootstrap: docker\nFrom: ubuntu:20.04\n</code></pre> <p>The <code>Bootstrap: docker</code> line is similar to prefixing an image path with <code>docker://</code> e.g. <code>apptainer pull</code> command. A range of different bootstrap options are supported. From: ubuntu:20.04 says that we want to use the ubuntu image with the tag 20.04 from Docker Hub.</p> <p>A definition also file has a number of optional sections, specified using the % prefix, that are used to define or undertake different configuration during different stages of the image build process. You can find full details in Apptainer\u2019s Definition Files documentation.</p> <p>In our very simple example here, we only use the <code>%post</code> and <code>%runscript</code> sections. The commands that appear in this section are standard shell commands and they are run within the context of our new container image. So, in the case of this example, these commands are being run within the context of a minimal Ubuntu 20.04 image that initially has only a very small set of core packages installed.</p> <p>Let\u2019s step through this definition file and look at the lines in more detail.</p> <p>First we have the <code>%post</code> section of the definition file:</p> <p>c</p> <pre><code>%post\napt-get -y update &amp;&amp; apt-get install -y python3\n</code></pre> <p>The <code>%post</code> section is where most of the customisation of your container will happen. This includes tasks such as package installation, pulling data files from remote locations and undertaking local configuration within the image.</p> <p>Here we use Ubuntu\u2019s package manager to update our package indexes and then install the <code>python3</code> package along with any required dependencies. The <code>-y</code> switches are used to accept, by default, interactive prompts that might appear asking you to confirm package updates or installation. This is required because our definition file should be able to run in an unattended, non-interactive environment.</p> <p>Finally we have the <code>%runscript</code> section:</p> <p>c</p> <pre><code>%runscript\n    python3 -c 'print(\"Hello World! Hello from our custom Apptainer image!\")'\n</code></pre> <p>This section is used to define a script that should be run when a container is started based on this image using the <code>apptainer run</code> command. In this simple example we use <code>python3</code> to print out some text to the console.</p> <p>Your full definition file should look like this:</p> <p>c</p> <pre><code>Bootstrap: docker\nFrom: ubuntu:20.04\n\n%post\n    apt-get -y update &amp;&amp; apt-get install -y python3\n\n%runscript\n    python3 -c 'print(\"Hello World! Hello from our custom Apptainer image!\")'\n</code></pre>"},{"location":"5.creating-container-images/#more-advanced-definition-files","title":"More advanced definition files","text":"<p>Here we\u2019ve looked at a very simple example of how to create an image. At this stage, you might want to have a go at creating your own definition file for some code of your own or an application that you work with regularly. There are several definition file sections that were not used in the above example, these are:</p> <ul> <li><code>%setup</code></li> <li><code>%files</code></li> <li><code>%environment</code></li> <li><code>%startscript</code></li> <li><code>%test</code></li> <li><code>%labels</code></li> <li><code>%help</code></li> </ul> <p>The Sections part of the definition file documentation details all the sections and provides an example definition file that makes use of all the sections.</p>"},{"location":"5.creating-container-images/#useful-base-images","title":"Useful base images","text":"<p>At the time of writing, Docker Hub is the most popular web registry for general purpose container images. Therefore all images mentioned below are hosted in this registry.</p> <p>Key points</p> <ul> <li><code>Definition files</code> specify what is within Apptainer container images.</li> <li>The <code>apptainer build</code> command is used to build a container image from a Definition file.</li> <li>Apptainer definition files are used to define the build process and configuration for an image.</li> <li>Existing images from remote registries such as Docker Hub and other public image repositories can be used as a base for creating new Apptainer images.</li> </ul>"},{"location":"5.creating-container-images/#cuda","title":"CUDA","text":"<p>nvidia/cuda has images to build GPU enabled applications. There are different image types for different needs. Tags containing <code>runtime</code> are suitable for binary applications that are ready to run; if you need to compile GPU code, pick tags containing <code>devel</code> instead. Different OS flavours are available, too.</p>"},{"location":"5.creating-container-images/#mpi","title":"MPI","text":"<p>As you can see in the episode on MPI applications, when containerising this type of software the MPI libraries in the image need to be ABI compatible with the MPI libraries in the host. The Pawsey Supercomputing Centre maintains some MPICH base images at pawsey/mpi-base, for building images that will run on our HPC systems.</p>"},{"location":"5.creating-container-images/#python","title":"Python","text":"<p>python hosts the official Python images. Different versions are available for some OS flavours. At the time of writing the default image tag corresponds to Python 3.8 on Debian 10. Smaller base images have tags ending with -slim.</p> <p>continuumio/miniconda3 are images provided by the maintainers of the Anaconda project. They ship with Python 3, as well as pip and conda to install and manage packages. At the time of writing, the most recent version is 4.7.12, based on Python 3.7.4.</p> <p>If you need interactive Jupyter Notebooks, Jupyter Docker Stacks maintain a series of dedicated container images. Among others, there is the base SciPy image jupyter/scipy-notebook, the data science image jupyter/datascience-notebook, and the machine learning image jupyter/tensorflow-notebook.</p>"},{"location":"5.creating-container-images/#r","title":"R","text":"<p>The Rocker Project maintains a number of good R base images. Of particular relevance is rocker/tidyverse, which embeds the basic R distribution, an RStudio web-server installation and the tidyverse collection of packages for data science. At the time of writing, the most recent version is 3.6.1.</p> <p>Other more basic images are rocker/r-ver (R only) and rocker/rstudio (R + RStudio).</p>"},{"location":"6.building-container-imaged/","title":"6. Building Container Images","text":"<p>Overview</p> <p>Questions</p> <ul> <li>How do I create my own Apptainer images?</li> </ul> <p>Objectives</p> <ul> <li>Understand the different Apptainer container file formats.</li> <li>Understand how to build and share your own Apptainer containers.</li> </ul> <p>So far you\u2019ve been able to work with Apptainer from your own user account as a non-privileged user.</p> <p>This part of the Apptainer material requires that you use Apptainer in an environment where you have administrative (root) access.</p> <p>There are a couple of different ways to work around this restriction.</p> pros cons Install Apptainer locally on a system where you do have administrative access (then then copy to HPC). <ul><li>Building a container locally first is great for testing.</li></ul> <ul><li>Not possible for many people.</li><li>Local machine must have same architecture as HPC.</li><li>Container image might be quite large and take a long time to copy.</li></ul> Build your container from within another container <ul><li>No root access required.</li></ul> <ul> <li>A bit contrived.</li> <li>Requires already having a built container with Apptainer installed.</li></ul> Use a 'remote build service' to build your container <ul><li>Convenient. Just one command to run.</li></ul> <ul><li>Requires access to a remote build service.</li><li>Build image must still be downloaded over network.</li> <li>Not currently available for Apptainer</li></ul> Simulate root access using the <code>--fakeroot</code> feature <ul><li>Convenient. Just an added flag.</li></ul> <ul><li>Not possible with all operating systems. (On NeSI, only our newer nodes with Rocky8 installed have this functionality.)</li></ul> <p>We\u2019ll focus on the last option in this part of the course - Simulate root access using the <code>--fakeroot</code> feature.</p> <p>Let's build our first container image</p> <ul> <li>Check the content of <code>my_container.def</code> file</li> </ul> <pre><code>Bootstrap: docker\nFrom: ubuntu:20.04\n\n%post\n    apt-get -y update &amp;&amp; apt-get install -y python3\n\n%runscript\n    python3 -c 'print(\"Hello World! Hello from our custom Apptainer image!\")'\n</code></pre> <ul> <li>Build command follows the format of <code>apptainer build --fakeroot name_of_the_image_file.sif name_of_the_definition_file.def</code> </li> </ul> <pre><code>$ apptainer build --fakeroot my_container.sif my_container.def \n</code></pre> <p>Check the image</p> <ul> <li>Once built, We can test our new container by running.</li> </ul> <pre><code>$ ./my_container.sif\n</code></pre> <p>Inspect the image</p> <pre><code>$ apptainer inspect my_container.sif\n</code></pre> <pre><code>org.label-schema.build-arch: amd64\norg.label-schema.build-date: Thursday_25_April_2024_14:43:40_NZST\norg.label-schema.schema-version: 1.0\norg.label-schema.usage.apptainer.version: 1.3.0\norg.label-schema.usage.singularity.deffile.bootstrap: docker\norg.label-schema.usage.singularity.deffile.from: ubuntu:20.04\norg.opencontainers.image.ref.name: ubuntu\norg.opencontainers.image.version: 20.04\n</code></pre>"},{"location":"6.building-container-imaged/#known-limitations","title":"Known limitations","text":"<p>This method, ( i.e using <code>fakeroot</code>), is known to not work for all types of Apptainer/Singularity containers.</p> <p>If your container uses RPM to install packages, i.e. is based on CentOS or Rocky Linux, you need to disable the <code>APPTAINER_TMPDIR</code> environment variable (use unset <code>APPTAINER_TMPDIR</code>) </p> <p>Few more examples</p> samtools-1.3.1 with HTSlib-1.3.2 <pre><code>Bootstrap: docker\nFrom: ubuntu:xenial\nStage: spython-base\n\n%labels\n    MAINTAINER NeSI/GA\n    description=\"Image for use with tools that require samtools, htslib, or tabix\"\n\n%post\n    apt-get update -y &amp;&amp; apt-get install -y \\\n    apt-utils \\\n    bzip2 \\\n    gcc \\\n    make \\\n    ncurses-dev \\\n    wget \\\n    zlib1g-dev\n\n    ##############\n    #HTSlib 1.3.2#\n    ##############\n    HTSLIB_INSTALL_DIR=/opt/htslib\n\n    mkdir -p /tmp\n    cd /tmp\n    wget https://github.com/samtools/htslib/releases/download/1.3.2/htslib-1.3.2.tar.bz2 &amp;&amp; \\\n    tar --bzip2 -xvf htslib-1.3.2.tar.bz2\n\n    mkdir -p /tmp/htslib-1.3.2\n    cd /tmp/htslib-1.3.2\n    ./configure  --enable-plugins --prefix=$HTSLIB_INSTALL_DIR &amp;&amp; \\\n    make &amp;&amp; \\\n    make install &amp;&amp; \\\n    cp $HTSLIB_INSTALL_DIR/lib/libhts.so* /usr/lib/\n\n    ################\n    #Samtools 1.3.1#\n    ################\n    SAMTOOLS_INSTALL_DIR=/opt/samtools\n\n    mkdir -p /tmp\n    cd /tmp\n    wget https://github.com/samtools/samtools/releases/download/1.3.1/samtools-1.3.1.tar.bz2 &amp;&amp; \\\n    tar --bzip2 -xf samtools-1.3.1.tar.bz2\n\n    mkdir -p /tmp/samtools-1.3.1\n    cd /tmp/samtools-1.3.1\n    ./configure --with-htslib=$HTSLIB_INSTALL_DIR --prefix=$SAMTOOLS_INSTALL_DIR &amp;&amp; \\\n    make &amp;&amp; \\\n    make install\n\n    mkdir -p /\n    cd /\n    rm -rf /tmp/samtools-1.3.1\n\n    #######\n    #tabix#\n    #######\n    ln -s $HTSLIB_INSTALL_DIR/bin/tabix /usr/bin/tabix\n    ln -s /opt/samtools/bin/* /usr/local/bin/\n\n%environment\n    export HTSLIB_INSTALL_DIR=/opt/htslib\n    export SAMTOOLS_INSTALL_DIR=/opt/samtools\n\n%runscript\n    cd /\n    exec /bin/bash \"$@\"\n\n%startscript\n    cd /\n    exec /bin/bash \"$@\"\n</code></pre> seqtk  - Using conda to install an application within a container image <ul> <li>All of us have built conda environment for some applications. One of the downsides of conda is it's appetite to generate a large number of files per environment.  One of the best solutions for this is to build the conda environment within the container image. This means the number of files consumed will be equal to 1 . Plus, it will make the sharing much more easier </li> </ul> <pre><code>Bootstrap: docker\nFrom: ubuntu:xenial\n\n%environment\n    export LC_ALL=C\n    export LC_NUMERIC=en_GB.UTF-8\n    export PATH=\"/opt/miniconda/bin:$PATH\"\n\n%labels\n        MAITAINER NeSI/GA\n        LICENSE MIT\n\n%help\n    Container for seqtk\n    Seqtk is a fast and lightweight tool for processing sequences in the FASTA or FASTQ format. It seamlessly parses both FASTA and FASTQ files which can also be optionally compressed by gzip.\n    https://github.com/lh3/seqtk\n\n    Version: 1.3\n    Package installation using Miniconda3-4.7.12\n    All packages are in /opt/miniconda/bin &amp; are in PATH\n    Default runscript: seqtk\n\n    Usage:\n        seqtk_v1.3.sif --help\n        or:\n        singularity exec seqtk_v1.3.sif seqtk --help\n\n\n%runscript\n    #default runscript: seqtk passing all arguments from cli: $@\n    exec /opt/miniconda/bin/seqtk \"$@\"\n\n%post\n\n    #essential stuff but minimal\n    apt update\n    #for security fixe:\n    #apt upgrade -y\n    apt install -y wget bzip2\n\n    #install conda\n    cd /opt\n    rm -fr miniconda\n\n    #miniconda3: get miniconda3 version 4.7.12\n    wget https://repo.anaconda.com/miniconda/Miniconda3-py39_24.3.0-0-Linux-x86_64.sh -O miniconda.sh\n\n    #install conda\n    bash miniconda.sh -b -p /opt/miniconda\n    export PATH=\"/opt/miniconda/bin:$PATH\"\n    #add channels\n    conda config --add channels defaults\n    conda config --add channels bioconda\n    conda config --add channels conda-forge\n\n    #install seqtk\n\n    conda install -y -c bioconda seqtk=1.3\n\n    #cleanup\n    conda clean -y --all\n    rm -f /opt/miniconda.sh\n    apt autoremove --purge\n    apt clean\n</code></pre>"}]}